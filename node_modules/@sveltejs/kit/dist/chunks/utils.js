import fs__default from 'fs';
import path from 'path';
import { $ } from '../cli.js';
import { fileURLToPath } from 'url';

/** @param {string} dir */
function mkdirp(dir) {
	try {
		fs__default.mkdirSync(dir, { recursive: true });
	} catch (e) {
		if (e.code === 'EEXIST') return;
		throw e;
	}
}

/** @param {string} path */
function rimraf(path) {
	(fs__default.rmSync || fs__default.rmdirSync)(path, { recursive: true, force: true });
}

/**
 * @param {string} from
 * @param {string} to
 * @param {(basename: string) => boolean} filter
 */
function copy(from, to, filter = () => true) {
	if (!fs__default.existsSync(from)) return [];
	if (!filter(path.basename(from))) return [];

	const files = [];
	const stats = fs__default.statSync(from);

	if (stats.isDirectory()) {
		fs__default.readdirSync(from).forEach((file) => {
			files.push(...copy(path.join(from, file), path.join(to, file)));
		});
	} else {
		mkdirp(path.dirname(to));
		fs__default.copyFileSync(from, to);
		files.push(to);
	}

	return files;
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/** @param {string} dest */
function copy_assets(dest) {
	let prefix = '..';
	do {
		// we jump through these hoops so that this function
		// works whether or not it's been bundled
		const resolved = path.resolve(__dirname, `${prefix}/assets`);

		if (fs__default.existsSync(resolved)) {
			copy(resolved, dest);
			return;
		}

		prefix = `../${prefix}`;
	} while (true); // eslint-disable-line
}

function noop() {}

/** @param {{ verbose: boolean }} opts */
function logger({ verbose }) {
	/** @type {import('types/internal').Logger} */
	const log = (msg) => console.log(msg.replace(/^/gm, '  '));

	log.success = (msg) => log($.green(`âœ” ${msg}`));
	log.error = (msg) => log($.bold().red(msg));
	log.warn = (msg) => log($.bold().yellow(msg));

	log.minor = verbose ? (msg) => log($.grey(msg)) : noop;
	log.info = verbose ? log : noop;

	return log;
}

/**
 * Given an entry point like [cwd]/src/hooks, returns a filename like [cwd]/src/hooks.js or [cwd]/src/hooks/index.js
 * @param {string} entry
 * @returns {string}
 */
function resolve_entry(entry) {
	if (fs__default.existsSync(entry)) {
		const stats = fs__default.statSync(entry);
		if (stats.isDirectory()) {
			return resolve_entry(path.join(entry, 'index'));
		}

		return entry;
	} else {
		const dir = path.dirname(entry);

		if (fs__default.existsSync(dir)) {
			const base = path.basename(entry);
			const files = fs__default.readdirSync(dir);

			const found = files.find((file) => file.replace(/\.[^.]+$/, '') === base);

			if (found) return path.join(dir, found);
		}
	}

	return null;
}

/** @param {string} str */
function posixify(str) {
	return str.replace(/\\/g, '/');
}

/**
 * Get a list of packages that use pkg.svelte, so they can be added
 * to ssr.noExternal. This is done on a best-effort basis to reduce
 * the frequency of 'Must use import to load ES Module' and similar
 * @param {string} cwd
 * @returns {string[]}
 */
function find_svelte_packages(cwd) {
	const pkg_file = path.join(cwd, 'package.json');
	if (!fs__default.existsSync(pkg_file)) return [];

	const pkg = JSON.parse(fs__default.readFileSync(pkg_file, 'utf8'));

	const deps = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.devDependencies || {})];

	return deps.filter((dep) => {
		const dep_pkg_file = path.join(cwd, 'node_modules', dep, 'package.json');
		if (!fs__default.existsSync(dep_pkg_file)) return false;

		const dep_pkg = JSON.parse(fs__default.readFileSync(dep_pkg_file, 'utf-8'));
		return !!dep_pkg.svelte;
	});
}

/**
 * @param {string} cwd
 * @param {string[]} [user_specified_deps]
 */
function get_no_external(cwd, user_specified_deps = []) {
	return [...user_specified_deps, ...find_svelte_packages(cwd)];
}

export { resolve_entry as a, copy as b, copy_assets as c, get_no_external as g, logger as l, mkdirp as m, posixify as p, rimraf as r };
